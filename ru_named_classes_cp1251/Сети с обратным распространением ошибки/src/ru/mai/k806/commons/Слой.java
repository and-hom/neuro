package ru.mai.k806.commons;

import java.util.Random;

/**
 * —лой в модели состоит из матрицы преобразовани€ функции активности нейронов
 */
public class —лой {
	/**
	 * ћатрица весов инициализируетс€ случайными значени€ми
	 */
	public —лой(int количество¬ходов, int количество¬ыходов, ‘ункци€јктивности функци€јктивности) {
		матрица¬есов = new double[количество¬ходов][количество¬ыходов];
		вектор—мещени€ = new double[количество¬ыходов];
		Random генератор—лучайных„исел = new Random();
		for (int j = 0; j < количество¬ыходов; j++) {
			вектор—мещени€[j] = генератор—лучайных„исел.nextDouble();
			for (int i = 0; i < количество¬ходов; i++)
				матрица¬есов[i][j] = генератор—лучайных„исел.nextDouble();
		}
		this.функци€јктивности = функци€јктивности;
	}

	/**
	 * ¬ектор смещени€ нулевой
	 */
	public —лой(double[][] матрица¬есов, ‘ункци€јктивности функци€јктивности) {
		this.функци€јктивности = функци€јктивности;
		this.матрица¬есов = матрица¬есов;
		this.вектор—мещени€ = new double[матрица¬есов[0].length];
	}

	public —лой(double[][] матрица¬есов, double[] вектор—мещени€, ‘ункци€јктивности функци€јктивности) {
		this.функци€јктивности = функци€јктивности;
		this.матрица¬есов = матрица¬есов;
		this.вектор—мещени€ = вектор—мещени€;
	}

	protected ‘ункци€јктивности функци€јктивности = new ѕорогова€‘ункци€јктивности();
	protected double[][] матрица¬есов = new double[1][1];
	protected double[] вектор—мещени€;

	/**
	 * ƒл€ каждого нейрона вычисл€ет комбинированный вход, примен€ет к нему ф-цию активности
	 * и возвращает вектор выходов дл€ всех нейронов
	 * выход =  вход * матрица¬есов + вектор—мещений
	 */
	public double[] преобразоватьƒаные(double[] вход—ло€) {
		// ƒлина вектора смещени€ равна длине выходного вектора сло€
		double[] выход—ло€ = new double[вектор—мещени€.length];
		// —умма всех входов, умноженна€ на соответствующие веса (взвешенна€ сумма)
		double входЌейрона = 0;
		//по всем нейронам
		for (int i = 0; i < вектор—мещени€.length; i++) {
			// по всем входам дл€ данного нейрона
			for (int j = 0; j < матрица¬есов.length; j++) {
				// умножаем вход на вес ребра, через которое сигнал входит
				входЌейрона += вход—ло€[j] * матрица¬есов[j][i];
			}
			// ƒобавл€ем смещение
			выход—ло€[i] = входЌейрона + вектор—мещени€[i];
			// ќбнул€ем переменную
			входЌейрона = 0;
		}
		return функци€јктивности.результат(выход—ло€);
	}

	public int получить–азмерность¬хода() {
		return матрица¬есов.length;
	}

	public int получить–азмерность¬ыхода() {
		return вектор—мещени€.length;
	}

	public void корректировать¬еса(double[] нормированна€ќшибка, double[] выход—ло€, double[] выходѕредыдущего—ло€, double нормаќбучени€,boolean flag) {
		// ѕо исход€щим
		//double[] изменение¬ектора—мещени€ = new double[вектор—мещени€.length];
		for (int j = 0; j < вектор—мещени€.length; j++) {
			вектор—мещени€[j] += нормированна€ќшибка[j];
			for (int i = 0; i < матрица¬есов.length; i++)
				матрица¬есов[i][j] += нормированна€ќшибка[j] * нормаќбучени€ * выходѕредыдущего—ло€[i] *
						  (flag?выход—ло€[j] * (1 - выход—ло€[j]):1);
		}
	}

	/**
	 * ѕропускаем ошибку через слой от выхода к входу
	 */
	public double[] обратный’од(double[] ошибка—ло€) {
		double[] ошибкаѕредыдущего—ло€ = new double[получить–азмерность¬хода()];
		for (int i = 0; i < получить–азмерность¬хода(); i++)
			for (int j = 0; j < получить–азмерность¬ыхода(); j++)
				ошибкаѕредыдущего—ло€[i] += ошибка—ло€[j] * матрица¬есов[i][j];
		return ошибкаѕредыдущего—ло€;
	}

	public void установить‘ункциюјктивности(‘ункци€јктивности функци€јктивности) {
		this.функци€јктивности = функци€јктивности;
	}
}
