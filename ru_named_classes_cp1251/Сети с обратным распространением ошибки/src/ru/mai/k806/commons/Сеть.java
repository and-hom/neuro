package ru.mai.k806.commons;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

/**
 * ќграничени€:
 * <ol>
 * <li>‘ункци€ активности задаЄтс€ только дл€ целого сло€ нейронов</li>
 * <li>ƒанные передаютс€ строго от сло€ к слою, ни один слой нельз€ обойти</li>
 * <li>ѕод слоем понимаетс€ сам слой нейронов и вход€щие в него рЄбра. “о есть,
 * входной слой вообще не считаетс€ слоем</li>
 * <li></li>
 * </ol>
 */
public class —еть {

	public —еть() {

	}

	public —еть(List<—лой> слои) throws Ќесовпадение–азмерности {
		for (—лой текущий—лой : слои)
			this.добавить—лой(текущий—лой);
	}

	public double[] получить–езультат(double[] исходныеƒанные) {
		// ѕеребор от 1-го скрытого к выходному
		double[] вход—ледующего—ло€ = исходныеƒанные;
		for (—лой текущий—лой : слои) {
			вход—ледующего—ло€ = текущий—лой.преобразоватьƒаные(вход—ледующего—ло€);
		}
		return вход—ледующего—ло€;
	}


	public void тренироватьс€(double[] исходныеƒанные, double[] правильныйќтвет)
			  throws Ќесовпадение–азмерности {
		// 1-й шаг - пр€мой проход
		double[][] результатыѕр€могоѕрохода = new double[слои.size()][];
		double[] вход—ледующего—ло€ = исходныеƒанные;
		int i = 0;
		for (—лой текущий—лой : слои) {
			вход—ледующего—ло€ = текущий—лой.преобразоватьƒаные(вход—ледующего—ло€);
			результатыѕр€могоѕрохода[i] = вход—ледующего—ло€;
			i++;
		}
		//double[] выход—ло€ = this.получить–езультат(исходныеƒанные);

		// 2-й шаг - проверка корректности входных данных
		i = результатыѕр€могоѕрохода.length - 1;

		// ≈сли размерности не совпадают, сеть построена некорректно
		if (результатыѕр€могоѕрохода[i].length != результатыѕр€могоѕрохода[i].length)
			throw new Ќесовпадение–азмерности("–азмерность равильного ответа не совпадает с размертностью вывода сети");

		List<—лой> слои¬ќбратномѕор€дке = new LinkedList<—лой>();
		//Collections.copy(слои¬ќбратномѕор€дке, слои);
		for (—лой слой : слои)
			слои¬ќбратномѕор€дке.add(слой);
		Collections.reverse(слои¬ќбратномѕор€дке);

		// получаем вектор нормаированной ошибки дл€ выходного сло€
		// по выходам нейронов
		double[] нормированна€ќшибка = new double[правильныйќтвет.length];
		if (i != 0)
			for (int j = 0; j < правильныйќтвет.length; j++)
				нормированна€ќшибка[j] = (правильныйќтвет[j] - результатыѕр€могоѕрохода[i][j]);// * нормаќбучени€;// * результатыѕр€могоѕрохода[i - 1][j];
		else
			for (int j = 0; j < правильныйќтвет.length; j++)
				нормированна€ќшибка[j] = (правильныйќтвет[j] - результатыѕр€могоѕрохода[i][j]);// * нормаќбучени€;//  * исходныеƒанные[j];

        boolean flag=true;
		double[] временна€ѕеременна€;
		// по сло€м от конца к началу
		for (—лой текущий—лой : слои¬ќбратномѕор€дке) {
			// корректируем веса
			if (i != 0)
				текущий—лой.корректировать¬еса(нормированна€ќшибка, результатыѕр€могоѕрохода[i], результатыѕр€могоѕрохода[i - 1], нормаќбучени€,flag);
			else
				текущий—лой.корректировать¬еса(нормированна€ќшибка, результатыѕр€могоѕрохода[i], исходныеƒанные, нормаќбучени€,flag);

            flag=false;
            // получаем выход
			нормированна€ќшибка = текущий—лой.обратный’од(нормированна€ќшибка);
			i--;
		}
	}


	public void добавить—лой(—лой слой) throws Ќесовпадение–азмерности {
		// ≈сли слоЄв нет, то провер€ть их на совместимость незачем
		// ≈сли размерность выхода последнего сло€ равна размерности входа добавл€емого, то всЄ правильно
		if (слои.size() == 0 ||
				  слой.получить–азмерность¬хода() == слои.get(слои.size() - 1).получить–азмерность¬ыхода())
			слои.add(слой);
		else
			throw new Ќесовпадение–азмерности("–азмерности выхода предыдущего сло€ и входа текущего не совпадают");
	}

	protected List<—лой> слои = new ArrayList<—лой>(3);
	protected double нормаќбучени€ = 0.3;

	public void установитьЌормуќбучени€(double нормаќбучени€) {
		this.нормаќбучени€ = нормаќбучени€;
	}

	public —лой получить—лой(int номер—ло€) {
		return слои.get(номер—ло€);
	}
}
